#!/usr/bin/env php
<?php
/**
 * msync
 * Synchronize directories like rsync but with an additional manifest so that
 * changes on the remote system are caught before damage is done.
 *
 * Written using MacOS 13.1 Ventura for the local workstation and
 * connecting to a server running Debian 10.
 */

use Model\Exceptions\HelpException;
use Model\Exceptions\NotInitializedException;
use Model\Manifest;
use Model\Opts;
use Model\Report;
use Model\Sync;

ini_set('error_reporting', E_ALL);

require 'vendor/diskerror/autoload/autoload.php';

const DATA_DIR      = '.msync/';
const MANIFEST_FILE = DATA_DIR . 'manifest.db';
const CONFIG_FILE   = DATA_DIR . 'config.ini';
const TEMP_DIR      = DATA_DIR . 'conflict/';

const USAGE = <<<'DEFINE_USAGE'
Usage:
	msync -H | --help
	msync [option [option [...]]] init | pull | push | resolve

DEFINE_USAGE;

$exitCode = 0;

////////////////////////////////////////////////////////////////////////////////////////////////////
//	MAIN

try {
	$opts = new Opts(CONFIG_FILE);
	
	$manifestFullPath = $opts->localPath . '/' . MANIFEST_FILE;

	if (!isset($argv[$opts->restIndex])) {
		fprintf(STDERR, USAGE . PHP_EOL);
		exit(1);
	}

	ini_set('memory_limit', '512M');

	if (!is_dir(DATA_DIR)) {
		mkdir(DATA_DIR);
	}

	//  Do command verb.
	switch ($argv[$opts->restIndex]) {
		case 'init':
			$report = new Report($opts->verbose);
			if (file_exists($manifestFullPath)) {
				$cont = 'no';   //  default reply
				$report->scream('This is an msync managed directory!');
				$report->scream('Do you wish to overwrite all working files? [y|N]:', false);
				if ($rline = readline(' ')) {
					$cont = $rline;
				}

				if (substr(strtolower($cont), 0, 1) !== 'y') {
					$report->out('Canceled.' . PHP_EOL);
					break;
				}
			}

			$report->out('Opening connection to remote server.');
			$sync = new Sync($opts);

			$report->out('Retrieving remote file list.');
			$remoteArray = $sync->getRemoteList();

			$report->out('Pulling new or different files.');
			$sync->pullFiles($remoteArray);

			$report->out('Writing file info to manifest.');
			(new Manifest($manifestFullPath, $opts))->firstWrite($remoteArray);

			$report->out('Initialization complete.');
			break;


		case 'pull':
			if (!file_exists($manifestFullPath)) {
				throw new NotInitializedException();
			}

			$sync        = new Sync($opts);
//			$remoteArray = $sync->getRemoteList();
//			$devArray    = $sync->getDevList();
			
			//  Build list of remote files that have changed.
		
			//  Build list of local files that have changed.

			//  Copy files from remote directory...
			//      If the local file has changed then
			//          put it in the conflict directory.
			//      Else,
			//          copy it in place.
		
			//  Write file stats into the manifest.
		
			//  If there are file in conflict then
			//      launch user's preferred "diff" engine to compare files.
			//      Or print paths to directories to compare.
			
			//  TODO: finnish this

			break;


		case 'push':
			if (!file_exists($manifestFullPath)) {
				throw new NotInitializedException();
			}

			$sync = new Sync($opts);
			
			//  Check conflict directory for files.
			//  If any,
			//      abort push and advise user.

			//  Build list of remote files that have changed.
			//  If any,
			//      abort push and advise user.

			//  Build list of local files that have changed.
		
			//  Push changed files to remote directory.

			//  Write file stats into the manifest.

			//  TODO: finnish this
			break;
			
			
		case 'resolve':
			if (!file_exists($manifestFullPath)) {
				throw new NotInitializedException();
			}

			//  Delete file from conflict directory.
		
			//  TODO: finnish this
		break;

			
		default:
			fprintf(STDERR, USAGE);
			$exitCode = 1;
	}
}
catch (HelpException $e) {
	fprintf(STDOUT, USAGE);
	fprintf(STDOUT, file_get_contents('help_screen.txt'));
}
catch (NotInitializedException $e) {
	$r = new Report($opts->verbose);
	$r->scream('This is not an msync managed directory.');
	$r->scream('Use ‘msync init’ to create local workspace.');
	$exitCode = 1;
}
catch (RuntimeException $e) {
	$r = new Report($opts->verbose);
	$r->scream($e->getMessage());
	$exitCode = $e->getCode();
}
catch (Throwable $t) {
	fprintf(STDERR, $t);
	$exitCode = $t->getCode();
}

exit($exitCode);
