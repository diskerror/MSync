#!/usr/bin/env php
<?php
/**
 * msync
 * Synchronize directories like rsync but with an additional manifest so that
 * changes on the remote system are caught before damage is done.
 *
 * Written using macOS 13.1 Ventura for the local workstation and
 * connecting to a server running Debian 10.
 */

use Laminas\Json\Exception\ExceptionInterface;
use Model\Manifest;
use Model\Opts;
use Model\Report;
use Model\Sync;

ini_set('error_reporting', E_ALL);

require 'vendor/diskerror/autoload/autoload.php';

const USAGE = <<<'NDOC'
Usage:
	msync -H | --help
	msync [option [option [...]]] init | pull | push | resolve «path»

NDOC;

const NOT_INITIALIZED = <<<'NDOC'
	This is not an msync managed directory.
	Use ‘msync init’ to create local workspace.
	
	NDOC;

function assertFileExists(string $file, string $message = '')
{
	if (!file_exists($file)) {
		throw new RuntimeException($message == '' ? '"' . $file . '" does not exist.' : $message);
	}
}

$exitCode = 0;

////////////////////////////////////////////////////////////////////////////////////////////////////
//	MAIN

try {
	$opts   = new Opts($argv);
	$report = new Report($opts->verbose);

	ini_set('memory_limit', '512M');

	//  Do command verb.
	switch ($argv[$opts->restIndex]) {
		case 'help':
			fprintf(STDOUT, USAGE . PHP_EOL);
			fprintf(STDOUT, file_get_contents(__DIR__ . '/help_screen.txt'));
			break;


		case 'init':
			if (file_exists($opts->manifestPath)) {
				$cont = 'no';   //  default reply
				$report->shout('This is an msync managed directory!');
				$report->shout('Do you wish to overwrite all working files? [y|N]: ', false);
				if ($rline = readline('')) {
					$cont = $rline;
				}

				if (substr(strtolower($cont), 0, 1) !== 'y') {
					$report->out('Canceled.' . PHP_EOL);
					break;
				}
			}

			$report->out('Opening connection to remote server.');
			$sync = new Sync($opts);

			$report->out('Retrieving remote file list.');
			$remoteArray = $sync->getRemoteList();

			$report->out('Pulling non-existent or files that differ.');
			$sync->pullFiles($remoteArray);

			$report->out('Writing file info to manifest.');
			(new Manifest($opts))->insertManyIntoManifest($remoteArray);

			$report->out('Initialization complete.');
			break;


		case 'pull':
			assertFileExists($opts->manifestPath, NOT_INITIALIZED);

			//  Build list of remote files that have changed or are new.
			$report->out('Opening connection to remote server.');
			$sync     = new Sync($opts);
			$manifest = new Manifest($opts);
			$manifest->addTempDb();

			$report->out('Retrieving remote file list.');
			$manifest->insertManyIntoTemp($sync->getRemoteList());

			//  Build list of local files that have changed or are new.

			//  Copy files from remote directory...
			//      If the local file has changed then
			//          put it in the conflict directory.
			//      Else,
			//          copy it in place.

			//  Write changed and new file stats into the manifest.

			//  If there are files in conflict then
			//      launch user's preferred "diff" engine to compare files.
			//      Or print paths to directories to compare.

			break;


		case 'push':
			assertFileExists($opts->manifestPath, NOT_INITIALIZED);

			//  Check conflict directory for files.
			//  If any, abort push and advise user.
			$rdi = new RecursiveIteratorIterator(
				new RecursiveDirectoryIterator($opts->conflictPath),
				FilesystemIterator::SKIP_DOTS | FilesystemIterator::CURRENT_AS_FILEINFO
			);
			foreach ($rdi as $f) {
				if ($f->getType === 'file') {
					$report->shout('Files are still in conflict. Aborting.');
					break 2;
				}
			}

			//  Build list of remote files that have changed or are new.
			//  If any, abort push and advise user.
			$report->out('Opening connection to remote server.');
			$sync     = new Sync($opts);
			$manifest = new Manifest($opts);
			$manifest->addTempDb();

			$report->out('Retrieving remote file list.');
			$manifest->insertManyIntoTemp($sync->getRemoteList());

			//  Build list of local files that have changed or are new.

			//  Push changed and new files to remote directory.

			//  Write changed and new file stats into the manifest.
			break;


		case 'resolve':
			assertFileExists($opts->manifestPath, NOT_INITIALIZED);

			if (!isset($argv[$opts->restIndex + 1])) {
				throw new UnderflowException('Missing path to file.');
			}

			$relativePath = ltrim($argv[$opts->restIndex + 1]);
			$fullPath     = realpath($opts->conflictPath . '/' . $relativePath);

			//  Written as assertions.
			switch (false){
				case (strpos($relativePath, '..') === false):
					throw new UnexpectedValueException('Cannot point to file outside project.');

				case ($relativePath[0] !== '/'):
					throw new UnexpectedValueException('Parameter must be a relative path to file.');
					
				case file_exists($fullPath):
					throw new UnexpectedValueException('File has been resolved or does not exist.');
					
				case is_file($fullPath):
					throw new UnexpectedValueException('Parameter must be a relative path to file.');
			}

			unlink($fullPath);
			$report->out('"' . $relativePath . '" has been removed.');
			break;


		default:
			throw new UnexpectedValueException('Unknown verb.');
	}
}
catch (ExceptionInterface $e) {
	fprintf(STDERR, $e . PHP_EOL);
	$exitCode = $e->getCode();
}
catch (RuntimeException $e) {
	fprintf(STDERR, $e->getMessage() . PHP_EOL);
	fprintf(STDERR, USAGE);
	$exitCode = $e->getCode();
}
catch (Throwable $t) {
	fprintf(STDERR, $t . PHP_EOL);
	$exitCode = $t->getCode();
}

exit($exitCode);
