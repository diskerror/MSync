#!/usr/bin/env php
<?php
/**
 * msync
 * Synchronize directories like rsync but with an additional manifest so that
 * changes on the remote system are caught before damage is done.
 *
 * Written using MacOS 13.1 Ventura for the local workstation and
 * connecting to a server running Debian 10.
 */

use Laminas\Json\Exception\ExceptionInterface;
use Model\Exceptions\StopException;
use Model\Manifest;
use Model\Opts;
use Model\Report;
use Model\Sync;

ini_set('error_reporting', E_ALL);

require 'vendor/diskerror/autoload/autoload.php';

const DATA_DIR      = '.msync/';
const MANIFEST_FILE = DATA_DIR . 'manifest.db';
const CONFIG_FILE   = DATA_DIR . 'config.ini';
const TEMP_DIR      = DATA_DIR . 'conflict/';

const USAGE = <<<'NDOC'
Usage:
	msync -H | --help
	msync [option [option [...]]] init | pull | push | resolve

NDOC;

const NOT_INITIALIZED = <<<'NDOC'
This is not an msync managed directory.
Use ‘msync init’ to create local workspace.

NDOC;

$exitCode = 0;

////////////////////////////////////////////////////////////////////////////////////////////////////
//	MAIN

try {
	$opts   = new Opts(CONFIG_FILE);
	$report = new Report($opts->verbose);

	$manifestFullPath = $opts->localPath . '/' . MANIFEST_FILE;

	if (!isset($argv[$opts->restIndex])) {
		throw new UnexpectedValueException('Missing parameter.');
	}

	ini_set('memory_limit', '512M');

	if (!is_dir(DATA_DIR)) {
		mkdir(DATA_DIR);
	}

	//  Do command verb.
	switch ($argv[$opts->restIndex]) {
		case 'init':
			$report = new Report($opts->verbose);
			if (file_exists($manifestFullPath)) {
				$cont = 'no';   //  default reply
				$report->scream('This is an msync managed directory!');
				$report->scream('Do you wish to overwrite all working files? [y|N]: ', false);
				if ($rline = readline('')) {
					$cont = $rline;
				}

				if (substr(strtolower($cont), 0, 1) !== 'y') {
					$report->out('Canceled.' . PHP_EOL);
					break;
				}
			}

			$report->out('Opening connection to remote server.');
			$sync = new Sync($opts);

			$report->out('Retrieving remote file list.');
			$remoteArray = $sync->getRemoteList();

			$report->out('Pulling new or different files.');
			$sync->pullFiles($remoteArray);

			$report->out('Writing file info to manifest.');
			(new Manifest($manifestFullPath, $opts))->firstWrite($remoteArray);

			$report->out('Initialization complete.');
			break;


		case 'pull':
			if (!file_exists($manifestFullPath)) {
				throw new RuntimeException(NOT_INITIALIZED);
			}

			$sync = new Sync($opts);
//			$remoteArray = $sync->getRemoteList();
//			$devArray    = $sync->getDevList();

			//  Build list of remote files that have changed.

			//  Build list of local files that have changed.

			//  Copy files from remote directory...
			//      If the local file has changed then
			//          put it in the conflict directory.
			//      Else,
			//          copy it in place.

			//  Write file stats into the manifest.

			//  If there are file in conflict then
			//      launch user's preferred "diff" engine to compare files.
			//      Or print paths to directories to compare.

			//  TODO: finnish this

			break;


		case 'push':
			if (!file_exists($manifestFullPath)) {
				throw new RuntimeException(NOT_INITIALIZED);
			}

			$sync = new Sync($opts);

			//  Check conflict directory for files.
			//  If any,
			//      abort push and advise user.

			//  Build list of remote files that have changed.
			//  If any,
			//      abort push and advise user.

			//  Build list of local files that have changed.

			//  Push changed files to remote directory.

			//  Write file stats into the manifest.

			//  TODO: finnish this
			break;


		case 'resolve':
			if (!file_exists($manifestFullPath)) {
				throw new RuntimeException(NOT_INITIALIZED);
			}

			//  Delete file from conflict directory.

			//  TODO: finnish this
			break;


		default:
			throw new UnexpectedValueException('Unknown verb.');
	}
}
catch (StopException $s) {
	fprintf(STDOUT, $s);
}
catch (ExceptionInterface $e) {
	fprintf(STDERR, $e . PHP_EOL);
	$exitCode = $e->getCode();
}
catch (RuntimeException $e) {
	fprintf(STDERR, $e->getMessage() . PHP_EOL . USAGE . PHP_EOL);
	$exitCode = $e->getCode();
}
catch (Throwable $t) {
	fprintf(STDERR, $t . PHP_EOL);
	$exitCode = $t->getCode();
}

exit($exitCode);
