#!/usr/bin/env php
<?php
/**
 * msync
 * Synchronize directories like rsync but with an additional manifest so that
 * changes on the remote system are caught before damage is done.
 *
 * Written using macOS 13.1 Ventura for the local workstation and
 * connecting to a server running Debian 10.
 */

use Laminas\Json\Exception\ExceptionInterface;
use Model\Manifest;
use Model\Opts;
use Model\Report;
use Model\Sync;

ini_set('error_reporting', E_ALL);

require 'vendor/diskerror/autoload/autoload.php';

const USAGE = <<<'NDOC'
Usage:
	msync -H | --help
	msync [option [option [...]]] init | pull | push | resolve «relative path»

NDOC;

const NOT_INITIALIZED = <<<'NDOC'
	This is not an msync managed directory.
	Use ‘msync init’ to create local workspace.
	
	NDOC;

function assertFileExists(string $file, string $message = '')
{
	if (!file_exists($file)) {
		throw new RuntimeException($message == '' ? '"' . $file . '" does not exist.' : $message);
	}
}

$exitCode = 0;

////////////////////////////////////////////////////////////////////////////////////////////////////
//	MAIN

try {
	$opts   = new Opts($argv);
	$report = new Report($opts->verbose);

	ini_set('memory_limit', '512M');

	//  Do command verb.
	switch ($opts->verb) {
		case 'help':
			fprintf(STDOUT, USAGE . PHP_EOL);
			fprintf(STDOUT, file_get_contents(__DIR__ . '/help_screen.txt'));
			break;


		case 'init':
			if (file_exists($opts->manifestPath)) {
				$cont = 'no';   //  default reply
				$report->shout('This is an msync managed directory!');
				$report->shout('Do you wish to overwrite all working files? [y|N]: ', false);
				if ($rline = readline('')) {
					$cont = $rline;
				}

				if (substr(strtolower($cont), 0, 1) !== 'y') {
					$report->out('Canceled.' . PHP_EOL);
					break;
				}
			}

			$report->out('Opening connection to remote server.');
			$sync = new Sync($opts);

			$report->out('Retrieving remote file list.');
			$remoteList = $sync->getRemoteList();

			$report->out('Pulling non-existent or files that differ.');
			$sync->pullFiles($remoteList);

			$report->out('Writing file info to manifest.');
			(new Manifest($opts->manifestPath))->write($remoteList);

			$report->out('Initialization complete.');
			break;


		case 'pull':
			assertFileExists($opts->manifestPath, NOT_INITIALIZED);

			//  Build list of remote files that have changed or are new.
			$report->out('Opening connection to remote server.');
			$sync     = new Sync($opts);
			$manifest = new Manifest($opts->manifestPath);

			$report->out('Retrieving remote file list.');
			$remoteList = $sync->getRemoteList();

			$report->out('Finding remote files that have changed.');
			$remoteChanged = $manifest->getChanged($remoteList);

			if (count($remoteChanged) === 0) {
				$report->shout('Nothing to do.');
				break;
			}

			//  Build list of local files that have changed.
			$report->out('Retrieving local files that have changed.');
			$localChanged = $manifest->getChanged($sync->getLocalList());

			//  Copy files from remote directory...
			//      If the local file has changed then
			//          put it in the conflict directory.
			//      Else,
			//          copy it in place.
			$conflicted = false;
			foreach ($remoteChanged as $rChangedFname => $rChangedInfo) {
				if (isset($localChanged[$rChangedFname]) && ($rChangedInfo['ftype'] === 'f')) {
					//  If a local file is changing from a link to a regular file then
					//      first delete the link or data will write to the wrong place.
					if (is_link($localChanged[$rChangedFname])) {
						unlink($rChangedFname);
					}

					$sync->pullToConflict($rChangedFname, $rChangedInfo);
					$conflicted = true;
				}
				else {
					$sync->pullFile($rChangedFname, $rChangedInfo);
				}
			}

			//  Write changed and new file stats into the manifest.
			$manifest->update($remoteChanged);

			//  If there are files in conflict then
			//      launch user's preferred "diff" engine to compare files.
			//      Or print paths to directories to compare.
			if ($conflicted) {
				exec('phpstorm diff "' . $opts->localPath . '" "' . $opts->conflictPath . '"');
			}
			else {
				$report->out('No conflicts.');
			}
			break;


		case 'push':
			assertFileExists($opts->manifestPath, NOT_INITIALIZED);
			
			if(!file_exists($opts->conflictPath) || !is_dir($opts->conflictPath)){
				mkdir($opts->conflictPath, 0755, true);
			}

			//  Check conflict directory for files.
			//  If any, abort push and advise user.
			$rdi = new RecursiveIteratorIterator(
				new RecursiveDirectoryIterator($opts->conflictPath),
				FilesystemIterator::SKIP_DOTS | FilesystemIterator::CURRENT_AS_FILEINFO
			);
			foreach ($rdi as $f) {
				if ($f->getType() === 'file') {
					$report->shout('Files are still in conflict. Aborting.');
					break 2;
				}
			}

			//  Build list of remote files that have changed or are new.
			//  If any, abort push and advise user.
			$report->out('Opening connection to remote server.');
			$sync     = new Sync($opts);
			$manifest = new Manifest($opts->manifestPath);

			$report->out('Retrieving remote file list.');
			$remoteList = $sync->getRemoteList();

			$report->out('Finding remote files that have changed.');
			$remoteChanged = $manifest->getChanged($sync->getRemoteList());

			if (count($remoteChanged) > 0) {
				$report->shout('There are changed files in the remote directory.');
				$report->shout('Perform a "pull" and check changes. Aborting.');
				break;
			}

			//  Build list of local files that have changed or are new.
			$report->out('Retrieving local files that have changed or are new.');
			$localChanged = $manifest->getChanged($sync->getLocalList());

			if (count($localChanged) === 0) {
				$report->out('Nothing to do.');
				break;
			}

			//  Push changed and new files to remote directory.
			$sync->pushFiles($localChanged, $remoteList);

			//  Write changed and new file stats into the manifest.
			$manifest->update($localChanged);
			break;


		case 'resolve':
			assertFileExists($opts->manifestPath, NOT_INITIALIZED);

			if (!isset($argv[$opts->restIndex + 1])) {
				throw new UnderflowException('Missing path to file.');
			}

			$relativePath = ltrim($argv[$opts->restIndex + 1]);
			$fullPath     = realpath($opts->conflictPath . '/' . $relativePath);

			//  Written as assertions.
			switch (false) {
				case (strpos($relativePath, '..') === false):
					throw new UnexpectedValueException('Cannot point to file outside project.');

				case ($relativePath[0] !== '/'):
					throw new UnexpectedValueException('Parameter must be a relative path to file.');

				case file_exists($fullPath):
					throw new UnexpectedValueException('File has been resolved or does not exist.');

				case is_file($fullPath):
					throw new UnexpectedValueException('Parameter must be a relative path to a regular file.');
			}

			unlink($fullPath);
			$report->out('"' . $relativePath . '" has been removed.');
			break;


		default:
			throw new UnexpectedValueException('Unknown verb.');
	}
}
catch (ExceptionInterface $e) {
	fprintf(STDERR, $e . PHP_EOL);
	$exitCode = $e->getCode();
}
catch (RuntimeException $e) {
	fprintf(STDERR, $e->getMessage() . PHP_EOL);
	fprintf(STDERR, USAGE);
	$exitCode = $e->getCode();
}
catch (Throwable $t) {
	fprintf(STDERR, $t . PHP_EOL);
	$exitCode = $t->getCode();
}

exit($exitCode);
